!function(g){var I={};function C(n){if(I[n])return I[n].exports;var l=I[n]={i:n,l:!1,exports:{}};return g[n].call(l.exports,l,l.exports,C),l.l=!0,l.exports}C.m=g,C.c=I,C.d=function(g,I,n){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:n})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var n=Object.create(null);if(C.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var l in g)C.d(n,l,function(I){return g[I]}.bind(null,l));return n},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="",C(C.s=8)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WallState; });\n/* harmony import */ var _MazeEntity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _Vertex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n\n\n\nconst WallState = {\n    PENDING: \'PENDING\',\n    CONFIRMED: \'CONFIRMED\',\n    REMOVED: \'REMOVED\'\n}\n\nclass Wall extends _MazeEntity_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] {\n    constructor(...args) {\n        super(...args);\n\n        this.state = (\n                this.row === 0 || this.row === this.maze.rows*2 ||\n                this.col === 0 || this.col === this.maze.cols*2\n            ) ? WallState.CONFIRMED : WallState.PENDING;\n    }\n\n    getVertices() {\n        const neighbors = this.getListOfNeighborsAtDist(1);\n        const vertices = neighbors.filter((neighbor) => neighbor instanceof _Vertex_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);\n        return vertices;\n    }\n\n    isRemovable() {\n        if (this.state !== WallState.PENDING) return false;\n\n        const vertices = this.getVertices();\n        for (let i = 0; i < 2; i++) {\n            if (vertices[i].hasMaximumRemovedWalls()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    shouldNotBeRemoved() {\n        const endpoints = this.getVertices();\n        for (let i = 0; i < 2; i++) {\n            if (endpoints[i].shouldNotRemoveWalls()) return true;\n        }\n        return false;\n    }\n}\n\n\n/* harmony default export */ __webpack_exports__["b"] = (Wall);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9XYWxsLmpzPzlkMDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1hemVFbnRpdHkgZnJvbSAnLi9NYXplRW50aXR5LmpzJztcbmltcG9ydCBWZXJ0ZXggZnJvbSAnLi9WZXJ0ZXguanMnO1xuXG5jb25zdCBXYWxsU3RhdGUgPSB7XG4gICAgUEVORElORzogJ1BFTkRJTkcnLFxuICAgIENPTkZJUk1FRDogJ0NPTkZJUk1FRCcsXG4gICAgUkVNT1ZFRDogJ1JFTU9WRUQnXG59XG5cbmNsYXNzIFdhbGwgZXh0ZW5kcyBNYXplRW50aXR5IHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSAoXG4gICAgICAgICAgICAgICAgdGhpcy5yb3cgPT09IDAgfHwgdGhpcy5yb3cgPT09IHRoaXMubWF6ZS5yb3dzKjIgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbCA9PT0gMCB8fCB0aGlzLmNvbCA9PT0gdGhpcy5tYXplLmNvbHMqMlxuICAgICAgICAgICAgKSA/IFdhbGxTdGF0ZS5DT05GSVJNRUQgOiBXYWxsU3RhdGUuUEVORElORztcbiAgICB9XG5cbiAgICBnZXRWZXJ0aWNlcygpIHtcbiAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gdGhpcy5nZXRMaXN0T2ZOZWlnaGJvcnNBdERpc3QoMSk7XG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gbmVpZ2hib3JzLmZpbHRlcigobmVpZ2hib3IpID0+IG5laWdoYm9yIGluc3RhbmNlb2YgVmVydGV4KTtcbiAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xuICAgIH1cblxuICAgIGlzUmVtb3ZhYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gV2FsbFN0YXRlLlBFTkRJTkcpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMuZ2V0VmVydGljZXMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlc1tpXS5oYXNNYXhpbXVtUmVtb3ZlZFdhbGxzKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc2hvdWxkTm90QmVSZW1vdmVkKCkge1xuICAgICAgICBjb25zdCBlbmRwb2ludHMgPSB0aGlzLmdldFZlcnRpY2VzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZW5kcG9pbnRzW2ldLnNob3VsZE5vdFJlbW92ZVdhbGxzKCkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7V2FsbFN0YXRlfVxuZXhwb3J0IGRlZmF1bHQgV2FsbFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return initUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return randInt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return getDeviceType; });\nfunction initUtils() {\n    Array.prototype.shuffle = function() {\n        for (let i = this.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [this[i], this[j]] = [this[j], this[i]];\n        }\n        return this;\n    }\n\n    $.fn.extend({\n        disable: function () {\n            $(this)\n                .attr('disabled', true)\n                .addClass('disabled')\n                .find('input').attr('disabled', true);\n        },\n        enable: function() {\n            $(this)\n                .attr('disabled', false)\n                .removeClass('disabled')\n                .find('input').attr('disabled', false);\n        }\n    });\n}\n\n// Min inclusive, max inclusive\nfunction randInt(min, max) {\n  return Math.floor(Math.random() * (max + 1 - min) ) + min;\n}\n\n// Returns true for mobile devices.\nfunction getDeviceType() {\n    let isMobile = false;\n    (function(a){if(/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0,4))) isMobile = true;})(navigator.userAgent||navigator.vendor||window.opera);\n    return isMobile;\n};\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy91dGlscy5qcz85OTQ0Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGluaXRVdGlscygpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuc2h1ZmZsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgICAgICAgICBbdGhpc1tpXSwgdGhpc1tqXV0gPSBbdGhpc1tqXSwgdGhpc1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgJC5mbi5leHRlbmQoe1xuICAgICAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKHRoaXMpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2Rpc2FibGVkJylcbiAgICAgICAgICAgICAgICAuZmluZCgnaW5wdXQnKS5hdHRyKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCh0aGlzKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkaXNhYmxlZCcsIGZhbHNlKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKVxuICAgICAgICAgICAgICAgIC5maW5kKCdpbnB1dCcpLmF0dHIoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8vIE1pbiBpbmNsdXNpdmUsIG1heCBpbmNsdXNpdmVcbmZ1bmN0aW9uIHJhbmRJbnQobWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggKyAxIC0gbWluKSApICsgbWluO1xufVxuXG4vLyBSZXR1cm5zIHRydWUgZm9yIG1vYmlsZSBkZXZpY2VzLlxuZnVuY3Rpb24gZ2V0RGV2aWNlVHlwZSgpIHtcbiAgICBsZXQgaXNNb2JpbGUgPSBmYWxzZTtcbiAgICAoZnVuY3Rpb24oYSl7aWYoLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLnRlc3QoYSl8fC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pLnRlc3QoYS5zdWJzdHIoMCw0KSkpIGlzTW9iaWxlID0gdHJ1ZTt9KShuYXZpZ2F0b3IudXNlckFnZW50fHxuYXZpZ2F0b3IudmVuZG9yfHx3aW5kb3cub3BlcmEpO1xuICAgIHJldHVybiBpc01vYmlsZTtcbn07XG5cbmV4cG9ydCB7aW5pdFV0aWxzLCByYW5kSW50LCBnZXREZXZpY2VUeXBlfTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("class MazeEntity {\n    constructor(maze, row, col) {\n        Object.assign(this, {maze, row, col});\n    }\n\n    /**\n     * Override toString to ensure unique key for object in hashtable.\n     */\n    toString() {\n        return `${this.constructor.name}_${this.row}_${this.col}`;\n    }\n\n    getDictOfNeighborsAtDist(distance) {\n        const data = this.maze.data, row = this.row, col = this.col;\n        return {\n            'left': col > (distance - 1) ? data[row][col - distance] : null,\n            'right': col < data[0].length - distance ? data[row][col + distance] : null,\n            'top': row > (distance - 1) ? data[row - distance][col] : null,\n            'bottom': row < data.length - distance ? data[row + distance][col] : null\n        }\n    }\n\n    getListOfNeighborsAtDist(distance) {\n        return Object.values(this.getDictOfNeighborsAtDist(distance)).filter((x) => x !== null)\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (MazeEntity);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9NYXplRW50aXR5LmpzP2E4YjEiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgTWF6ZUVudGl0eSB7XG4gICAgY29uc3RydWN0b3IobWF6ZSwgcm93LCBjb2wpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7bWF6ZSwgcm93LCBjb2x9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0b1N0cmluZyB0byBlbnN1cmUgdW5pcXVlIGtleSBmb3Igb2JqZWN0IGluIGhhc2h0YWJsZS5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX1fJHt0aGlzLnJvd31fJHt0aGlzLmNvbH1gO1xuICAgIH1cblxuICAgIGdldERpY3RPZk5laWdoYm9yc0F0RGlzdChkaXN0YW5jZSkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5tYXplLmRhdGEsIHJvdyA9IHRoaXMucm93LCBjb2wgPSB0aGlzLmNvbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdsZWZ0JzogY29sID4gKGRpc3RhbmNlIC0gMSkgPyBkYXRhW3Jvd11bY29sIC0gZGlzdGFuY2VdIDogbnVsbCxcbiAgICAgICAgICAgICdyaWdodCc6IGNvbCA8IGRhdGFbMF0ubGVuZ3RoIC0gZGlzdGFuY2UgPyBkYXRhW3Jvd11bY29sICsgZGlzdGFuY2VdIDogbnVsbCxcbiAgICAgICAgICAgICd0b3AnOiByb3cgPiAoZGlzdGFuY2UgLSAxKSA/IGRhdGFbcm93IC0gZGlzdGFuY2VdW2NvbF0gOiBudWxsLFxuICAgICAgICAgICAgJ2JvdHRvbSc6IHJvdyA8IGRhdGEubGVuZ3RoIC0gZGlzdGFuY2UgPyBkYXRhW3JvdyArIGRpc3RhbmNlXVtjb2xdIDogbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TGlzdE9mTmVpZ2hib3JzQXREaXN0KGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuZ2V0RGljdE9mTmVpZ2hib3JzQXREaXN0KGRpc3RhbmNlKSkuZmlsdGVyKCh4KSA9PiB4ICE9PSBudWxsKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWF6ZUVudGl0eTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _MazeEntity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _Wall_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);\n\n\n\nclass Vertex extends _MazeEntity_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] {\n    constructor(...args) {\n        super(...args);\n    }\n\n    getOutgoingWalls() {\n        return this.getListOfNeighborsAtDist(1)\n    }\n\n    // The maximum number of outgoing walls a vertex can have in the REMOVED\n    // state is 3.\n    hasMaximumRemovedWalls() {\n        return this.getOutgoingWalls()\n            .filter((wall) => wall.state === _Wall_js__WEBPACK_IMPORTED_MODULE_1__[/* WallState */ "a"].REMOVED)\n            .length >= 3\n    }\n\n    // Call this function on both endpoints, when considering whether to remove a PENDING wall.\n    // It is a recommendation, rather than a hard rule.\n    shouldNotRemoveWalls() {\n        const walls = this.getOutgoingWalls();\n        const confirmedWalls = walls.filter((wall) => wall.state === _Wall_js__WEBPACK_IMPORTED_MODULE_1__[/* WallState */ "a"].CONFIRMED);\n        const pendingWalls = walls.filter((wall) => wall.state === _Wall_js__WEBPACK_IMPORTED_MODULE_1__[/* WallState */ "a"].PENDING);\n\n        // If at least 2 confirmed walls, there can\'t be a lone wall.\n        // If 0, it\'s possible there could be a lone wall later down the road...\n        if (confirmedWalls.length !== 1) return false;\n\n        // If another wall which *could* be confirmed in the future, we\'re safe for now.\n        if (pendingWalls.length > 1) return false;\n\n        const wall = confirmedWalls[0];\n        const vertices = wall.getVertices();\n\n        // Get vertex at other end of wall.\n        for (let i = 0; i < 2; i++) {\n            const vertex = vertices[i];\n            if (vertex === this) continue;\n\n            // Check whether wall is (or could be) supported at its other vertex.\n            const removedWalls = vertex.getOutgoingWalls().filter((wall) => wall.state === _Wall_js__WEBPACK_IMPORTED_MODULE_1__[/* WallState */ "a"].REMOVED);\n            if (removedWalls.length === 3) return true;\n        }\n\n        return false;\n    }\n}\n\n/* harmony default export */ __webpack_exports__["a"] = (Vertex);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9WZXJ0ZXguanM/NDg3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWF6ZUVudGl0eSBmcm9tICcuL01hemVFbnRpdHkuanMnO1xuaW1wb3J0IHtXYWxsU3RhdGV9IGZyb20gJy4vV2FsbC5qcydcblxuY2xhc3MgVmVydGV4IGV4dGVuZHMgTWF6ZUVudGl0eSB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICB9XG5cbiAgICBnZXRPdXRnb2luZ1dhbGxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaXN0T2ZOZWlnaGJvcnNBdERpc3QoMSlcbiAgICB9XG5cbiAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygb3V0Z29pbmcgd2FsbHMgYSB2ZXJ0ZXggY2FuIGhhdmUgaW4gdGhlIFJFTU9WRURcbiAgICAvLyBzdGF0ZSBpcyAzLlxuICAgIGhhc01heGltdW1SZW1vdmVkV2FsbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE91dGdvaW5nV2FsbHMoKVxuICAgICAgICAgICAgLmZpbHRlcigod2FsbCkgPT4gd2FsbC5zdGF0ZSA9PT0gV2FsbFN0YXRlLlJFTU9WRUQpXG4gICAgICAgICAgICAubGVuZ3RoID49IDNcbiAgICB9XG5cbiAgICAvLyBDYWxsIHRoaXMgZnVuY3Rpb24gb24gYm90aCBlbmRwb2ludHMsIHdoZW4gY29uc2lkZXJpbmcgd2hldGhlciB0byByZW1vdmUgYSBQRU5ESU5HIHdhbGwuXG4gICAgLy8gSXQgaXMgYSByZWNvbW1lbmRhdGlvbiwgcmF0aGVyIHRoYW4gYSBoYXJkIHJ1bGUuXG4gICAgc2hvdWxkTm90UmVtb3ZlV2FsbHMoKSB7XG4gICAgICAgIGNvbnN0IHdhbGxzID0gdGhpcy5nZXRPdXRnb2luZ1dhbGxzKCk7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1lZFdhbGxzID0gd2FsbHMuZmlsdGVyKCh3YWxsKSA9PiB3YWxsLnN0YXRlID09PSBXYWxsU3RhdGUuQ09ORklSTUVEKTtcbiAgICAgICAgY29uc3QgcGVuZGluZ1dhbGxzID0gd2FsbHMuZmlsdGVyKCh3YWxsKSA9PiB3YWxsLnN0YXRlID09PSBXYWxsU3RhdGUuUEVORElORyk7XG5cbiAgICAgICAgLy8gSWYgYXQgbGVhc3QgMiBjb25maXJtZWQgd2FsbHMsIHRoZXJlIGNhbid0IGJlIGEgbG9uZSB3YWxsLlxuICAgICAgICAvLyBJZiAwLCBpdCdzIHBvc3NpYmxlIHRoZXJlIGNvdWxkIGJlIGEgbG9uZSB3YWxsIGxhdGVyIGRvd24gdGhlIHJvYWQuLi5cbiAgICAgICAgaWYgKGNvbmZpcm1lZFdhbGxzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIElmIGFub3RoZXIgd2FsbCB3aGljaCAqY291bGQqIGJlIGNvbmZpcm1lZCBpbiB0aGUgZnV0dXJlLCB3ZSdyZSBzYWZlIGZvciBub3cuXG4gICAgICAgIGlmIChwZW5kaW5nV2FsbHMubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IHdhbGwgPSBjb25maXJtZWRXYWxsc1swXTtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSB3YWxsLmdldFZlcnRpY2VzKCk7XG5cbiAgICAgICAgLy8gR2V0IHZlcnRleCBhdCBvdGhlciBlbmQgb2Ygd2FsbC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgaWYgKHZlcnRleCA9PT0gdGhpcykgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgd2FsbCBpcyAob3IgY291bGQgYmUpIHN1cHBvcnRlZCBhdCBpdHMgb3RoZXIgdmVydGV4LlxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZFdhbGxzID0gdmVydGV4LmdldE91dGdvaW5nV2FsbHMoKS5maWx0ZXIoKHdhbGwpID0+IHdhbGwuc3RhdGUgPT09IFdhbGxTdGF0ZS5SRU1PVkVEKTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkV2FsbHMubGVuZ3RoID09PSAzKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZlcnRleDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n')},function(module,exports){eval("module.exports = jQuery;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImpRdWVyeVwiP2NkMGMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBqUXVlcnk7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXTERNAL MODULE: ./src/js/utils.js\nvar utils = __webpack_require__(1);\n\n// EXTERNAL MODULE: ./src/js/MazeEntity.js\nvar MazeEntity = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./src/js/Wall.js\nvar Wall = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/js/Cell.js\n\n\n\n\nclass Cell_Group {\n    constructor(cell) {\n        this.accessibleUnvisitedCells = new Set([cell]);\n        this.memberCells = [cell];\n        this.color = `rgb(${Object(utils["c" /* randInt */])(0,255)}, ${Object(utils["c" /* randInt */])(0,255)}, ${Object(utils["c" /* randInt */])(0,255)})`;\n    }\n\n    mergeWithGroup(group) {\n        const [deprecatedGroup, persistingGroup] = [this, group].sort((a,b) => a.memberCells.length > b.memberCells.length ? 1 : -1);\n        deprecatedGroup.memberCells.forEach((cell) => cell.group = persistingGroup);\n        persistingGroup.memberCells = persistingGroup.memberCells.concat(deprecatedGroup.memberCells);\n    }\n}\n\nclass Cell_Cell extends MazeEntity["a" /* default */] {\n    constructor(...args) {\n        super(...args);\n\n        this.group = new Cell_Group(this);\n        this.visited = false;\n    }\n\n    /**\n     * @returns {Array.<Cell>} List of neighboring cells\n     */\n    getNeighboringCells() {\n        return this.getListOfNeighborsAtDist(2)\n    }\n\n    /**\n     * @param {Cell} cell\n     * @returns {boolean} Represents whether there is a removed wall between cells\n     */\n\n    canAccessCell(cell) {\n        return (\n            this.isNeighboringCell(cell)\n            && this.getInterveningWall(cell).state === Wall["a" /* WallState */].REMOVED\n        )\n    }\n\n    getInterveningWall(cell) {\n        if (this.isNeighboringCell(cell)) {\n            return this.maze.data[(this.row + cell.row) / 2][(this.col + cell.col) / 2]\n        }\n        return null;\n    }\n\n    isNeighboringCell(cell) {\n        return this.getNeighboringCells().includes(cell);\n    }\n\n    /**\n     * @returns {Array.<Cell>} List of neighboring cells that are accessible\n     */\n    getAccessibleNeighbors() {\n        return this.getNeighboringCells().filter((c) => this.canAccessCell(c))\n    }\n\n    getUniqueNeighboringGroups(onlyVisited) {\n        let accessibleNeighbors = this.getAccessibleNeighbors()\n        if (onlyVisited) accessibleNeighbors = accessibleNeighbors.filter((neighbor) => neighbor.visited)\n\n        return accessibleNeighbors.reduce((acc, neighbor)=>{\n            return acc.includes(neighbor.group) ? acc : acc.concat([neighbor.group])\n        }, []);\n    }\n\n    /**\n     * @returns {Object} Dictionary of walls surrounding this cell\n     */\n    getWalls() {\n        return this.getDictOfNeighborsAtDist(1)\n    }\n\n    removeAtLeastNWalls(minimumWallsToRemove){\n        const walls = Object.values(this.getWalls()).shuffle();\n\n        // Move walls that shouldn\'t be removed later in list, to decrease chance of removal.\n        walls.sort((a, b) => a.shouldNotBeRemoved() && !b.shouldNotBeRemoved() ? 1 : -1);\n\n        const removableWalls = walls.filter((wall)=>wall.isRemovable())\n        const numberOfWallsToRemove = Object(utils["c" /* randInt */])(minimumWallsToRemove, removableWalls.length);\n\n        let removedWalls = 0;\n        walls.forEach((wall)=>{\n            if(wall.state==Wall["a" /* WallState */].PENDING){\n                if (removableWalls.includes(wall) && removedWalls < numberOfWallsToRemove) {\n                    if (wall.shouldNotBeRemoved() && removedWalls > minimumWallsToRemove) {\n                        wall.state = Wall["a" /* WallState */].CONFIRMED;\n                        return;\n                    }\n                    wall.state = Wall["a" /* WallState */].REMOVED;\n                    removedWalls++;\n                } else {\n                    wall.state = Wall["a" /* WallState */].CONFIRMED\n                }\n            }\n        });\n    }\n\n    visit() {\n        // Get the groups that will be merged with this cell. For each one,\n        // this cell no longer counts as an "accessible unvisited cell", so\n        // delete it from their records.\n        let neighboringGroups = this.getUniqueNeighboringGroups();\n        neighboringGroups.forEach(\n                (group)=> group.accessibleUnvisitedCells.delete(this)\n        )\n\n        // If the merged group which includes this cell already has access to\n        // a least one unvisited cell, then we don\'t need to remove any walls.\n        // If it does NOT have access to at least one unvisited cell, we need\n        // to maintain access by deleting at least one wall.\n        const minWallsToRemove =\n            getAllAccessibleUnvisitedCells(neighboringGroups).size ? 0 : 1;\n\n        // Remove at least the specified number of walls.\n        this.removeAtLeastNWalls(minWallsToRemove)\n\n        // Now that we\'ve removed some walls, re-calculate the neighboring\n        // groups to include those that we have just gained access to.\n        // Once we merge, we\'ll want the newly merged group to count, among its\n        // "accessible unvisited cells", anything accessible via these neighboring\n        // groups\n        neighboringGroups = this.getUniqueNeighboringGroups();\n        const newAllUnvisited = getAllAccessibleUnvisitedCells(neighboringGroups)\n\n        // Perform the merge & update the "accessible unvisited cells"\n        this.getUniqueNeighboringGroups(true)\n            .forEach((group) => this.group.mergeWithGroup(group));\n        this.group.accessibleUnvisitedCells = newAllUnvisited;\n\n        // Mark this cell as visited\n        this.visited = true;\n    }\n\n}\n\nfunction getAllAccessibleUnvisitedCells(groups){\n    const allUnvisitedCells = new Set();\n    groups.forEach((group) => {\n        group.accessibleUnvisitedCells.forEach((cell)=>{\n            allUnvisitedCells.add(cell)\n        })\n    });\n    return allUnvisitedCells;\n}\n\n/* harmony default export */ var js_Cell = (Cell_Cell);\n\n// EXTERNAL MODULE: ./src/js/Vertex.js\nvar Vertex = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./src/js/Maze.js\n\n\n\n\n\nclass Maze_Maze {\n    constructor(rows, cols) {\n        this.rows = rows;\n        this.cols = cols;\n        this.data = [];\n        this.visitedCellsCount = 0;\n\n        const dataTypes = [\n            [Vertex["a" /* default */], Wall["b" /* default */]],\n            [Wall["b" /* default */], js_Cell]\n        ];\n\n        for (let r = 0; r < 2*rows+1; r++) {\n            const row = [];\n            for (let c = 0; c < 2*cols+1; c++) {\n                // Initialize each entity with its coordinates and a reference to the maze.\n                row.push(new dataTypes[r%2][c%2](this, r, c));\n            }\n            this.data.push(row);\n        }\n    }\n\n    getCells() {\n        return this.data.reduce((cells, row) => {\n            return cells.concat(row.filter((entity) => entity instanceof js_Cell));\n        }, []);\n    }\n\n    generateMaze() {\n        if (this.visitedCellsCount > 0) return;\n        while (this.generateNextCell()) {}\n    }\n\n    generateNextCell() {\n        const cells = this.getCells();\n        if (this.visitedCellsCount === cells.length) return false;\n\n        const cell = cells[this.visitedCellsCount];\n        cell.visit();\n        this.visitedCellsCount++;\n\n        return true;\n    }\n\n    /**\n     * Generic implementation of breadth-first search. Returns nothing, but exposes\n     * customizable functionality via callback function.\n     *\n     * @param {Cell} startCell - Cell to begin searching outwards from.\n     * @param {Function} callback - Takes parent Cell, followed by its child Cell.\n     */\n    breadthFirstSearch(startCell, callback) {\n        const distanceDict = {};\n        const visitedCells = new Set([startCell]);\n\n        let frontierCells = [startCell];\n\n        while (frontierCells.length) {\n            const newFrontier = [];\n            frontierCells.forEach((cell) => {\n                const accessibleNeighbors = cell.getAccessibleNeighbors();\n                const unvisitedAccessible = accessibleNeighbors.filter((neighbor) => !visitedCells.has(neighbor));\n\n                unvisitedAccessible.forEach((unvisited) => {\n                    callback(cell, unvisited)\n                    newFrontier.push(unvisited);\n                    visitedCells.add(unvisited);\n                });\n            });\n            frontierCells = newFrontier;\n        }\n    }\n\n    /**\n     * Calculate distance of all maze cells from cell at given index,\n     * then use color to visualize distance.\n     *\n     * @param {number} startIdx - Index of selected start cell.\n     * @returns {Object.<Cell, number>} Dictionary of distances from start cell.\n     */\n    getDistanceDict(startIdx){\n        const startCell = this.getCells()[startIdx];\n        const distanceDict = {}\n        distanceDict[startCell] = 0;\n\n        this.breadthFirstSearch(startCell, (parent, child)=>{\n            distanceDict[child] = distanceDict[parent] + 1;\n        });\n\n        return distanceDict;\n    }\n\n    /**\n     * Uses breadth-first search to find the shortest path between two cells.\n     *\n     * @param {number} startIdx - Index of start cell.\n     * @param {number} endIdx - Index of end cell.\n     * @returns {Array} List of cells in shortest path (including start and end cell).\n     */\n    getShortestPathData(startIdx, endIdx){\n        const cells = this.getCells();\n        const startCell = cells[startIdx];\n        const endCell = cells[endIdx];\n\n        const previousDict = {}\n        previousDict[startCell] = null;\n\n        this.breadthFirstSearch(startCell, (parent, child) => {\n            previousDict[child] = parent;\n        });\n\n        const path = [];\n\n        let prevCell = endCell;\n        while (prevCell !== null) {\n            path.unshift(prevCell)\n            prevCell = previousDict[prevCell];\n        }\n\n        return path;\n    }\n}\n\n/* harmony default export */ var js_Maze = __webpack_exports__["a"] = (Maze_Maze);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9DZWxsLmpzPzYxYTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL01hemUuanM/NDQ2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3JhbmRJbnR9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IE1hemVFbnRpdHkgZnJvbSAnLi9NYXplRW50aXR5LmpzJztcbmltcG9ydCB7V2FsbFN0YXRlfSBmcm9tICcuL1dhbGwuanMnXG5cbmNsYXNzIEdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihjZWxsKSB7XG4gICAgICAgIHRoaXMuYWNjZXNzaWJsZVVudmlzaXRlZENlbGxzID0gbmV3IFNldChbY2VsbF0pO1xuICAgICAgICB0aGlzLm1lbWJlckNlbGxzID0gW2NlbGxdO1xuICAgICAgICB0aGlzLmNvbG9yID0gYHJnYigke3JhbmRJbnQoMCwyNTUpfSwgJHtyYW5kSW50KDAsMjU1KX0sICR7cmFuZEludCgwLDI1NSl9KWA7XG4gICAgfVxuXG4gICAgbWVyZ2VXaXRoR3JvdXAoZ3JvdXApIHtcbiAgICAgICAgY29uc3QgW2RlcHJlY2F0ZWRHcm91cCwgcGVyc2lzdGluZ0dyb3VwXSA9IFt0aGlzLCBncm91cF0uc29ydCgoYSxiKSA9PiBhLm1lbWJlckNlbGxzLmxlbmd0aCA+IGIubWVtYmVyQ2VsbHMubGVuZ3RoID8gMSA6IC0xKTtcbiAgICAgICAgZGVwcmVjYXRlZEdyb3VwLm1lbWJlckNlbGxzLmZvckVhY2goKGNlbGwpID0+IGNlbGwuZ3JvdXAgPSBwZXJzaXN0aW5nR3JvdXApO1xuICAgICAgICBwZXJzaXN0aW5nR3JvdXAubWVtYmVyQ2VsbHMgPSBwZXJzaXN0aW5nR3JvdXAubWVtYmVyQ2VsbHMuY29uY2F0KGRlcHJlY2F0ZWRHcm91cC5tZW1iZXJDZWxscyk7XG4gICAgfVxufVxuXG5jbGFzcyBDZWxsIGV4dGVuZHMgTWF6ZUVudGl0eSB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcblxuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IEdyb3VwKHRoaXMpO1xuICAgICAgICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPENlbGw+fSBMaXN0IG9mIG5laWdoYm9yaW5nIGNlbGxzXG4gICAgICovXG4gICAgZ2V0TmVpZ2hib3JpbmdDZWxscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGlzdE9mTmVpZ2hib3JzQXREaXN0KDIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDZWxsfSBjZWxsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJlcHJlc2VudHMgd2hldGhlciB0aGVyZSBpcyBhIHJlbW92ZWQgd2FsbCBiZXR3ZWVuIGNlbGxzXG4gICAgICovXG5cbiAgICBjYW5BY2Nlc3NDZWxsKGNlbGwpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaXNOZWlnaGJvcmluZ0NlbGwoY2VsbClcbiAgICAgICAgICAgICYmIHRoaXMuZ2V0SW50ZXJ2ZW5pbmdXYWxsKGNlbGwpLnN0YXRlID09PSBXYWxsU3RhdGUuUkVNT1ZFRFxuICAgICAgICApXG4gICAgfVxuXG4gICAgZ2V0SW50ZXJ2ZW5pbmdXYWxsKGNlbGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWlnaGJvcmluZ0NlbGwoY2VsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hemUuZGF0YVsodGhpcy5yb3cgKyBjZWxsLnJvdykgLyAyXVsodGhpcy5jb2wgKyBjZWxsLmNvbCkgLyAyXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlzTmVpZ2hib3JpbmdDZWxsKGNlbGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmVpZ2hib3JpbmdDZWxscygpLmluY2x1ZGVzKGNlbGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48Q2VsbD59IExpc3Qgb2YgbmVpZ2hib3JpbmcgY2VsbHMgdGhhdCBhcmUgYWNjZXNzaWJsZVxuICAgICAqL1xuICAgIGdldEFjY2Vzc2libGVOZWlnaGJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5laWdoYm9yaW5nQ2VsbHMoKS5maWx0ZXIoKGMpID0+IHRoaXMuY2FuQWNjZXNzQ2VsbChjKSlcbiAgICB9XG5cbiAgICBnZXRVbmlxdWVOZWlnaGJvcmluZ0dyb3Vwcyhvbmx5VmlzaXRlZCkge1xuICAgICAgICBsZXQgYWNjZXNzaWJsZU5laWdoYm9ycyA9IHRoaXMuZ2V0QWNjZXNzaWJsZU5laWdoYm9ycygpXG4gICAgICAgIGlmIChvbmx5VmlzaXRlZCkgYWNjZXNzaWJsZU5laWdoYm9ycyA9IGFjY2Vzc2libGVOZWlnaGJvcnMuZmlsdGVyKChuZWlnaGJvcikgPT4gbmVpZ2hib3IudmlzaXRlZClcblxuICAgICAgICByZXR1cm4gYWNjZXNzaWJsZU5laWdoYm9ycy5yZWR1Y2UoKGFjYywgbmVpZ2hib3IpPT57XG4gICAgICAgICAgICByZXR1cm4gYWNjLmluY2x1ZGVzKG5laWdoYm9yLmdyb3VwKSA/IGFjYyA6IGFjYy5jb25jYXQoW25laWdoYm9yLmdyb3VwXSlcbiAgICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IERpY3Rpb25hcnkgb2Ygd2FsbHMgc3Vycm91bmRpbmcgdGhpcyBjZWxsXG4gICAgICovXG4gICAgZ2V0V2FsbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERpY3RPZk5laWdoYm9yc0F0RGlzdCgxKVxuICAgIH1cblxuICAgIHJlbW92ZUF0TGVhc3ROV2FsbHMobWluaW11bVdhbGxzVG9SZW1vdmUpe1xuICAgICAgICBjb25zdCB3YWxscyA9IE9iamVjdC52YWx1ZXModGhpcy5nZXRXYWxscygpKS5zaHVmZmxlKCk7XG5cbiAgICAgICAgLy8gTW92ZSB3YWxscyB0aGF0IHNob3VsZG4ndCBiZSByZW1vdmVkIGxhdGVyIGluIGxpc3QsIHRvIGRlY3JlYXNlIGNoYW5jZSBvZiByZW1vdmFsLlxuICAgICAgICB3YWxscy5zb3J0KChhLCBiKSA9PiBhLnNob3VsZE5vdEJlUmVtb3ZlZCgpICYmICFiLnNob3VsZE5vdEJlUmVtb3ZlZCgpID8gMSA6IC0xKTtcblxuICAgICAgICBjb25zdCByZW1vdmFibGVXYWxscyA9IHdhbGxzLmZpbHRlcigod2FsbCk9PndhbGwuaXNSZW1vdmFibGUoKSlcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZXYWxsc1RvUmVtb3ZlID0gcmFuZEludChtaW5pbXVtV2FsbHNUb1JlbW92ZSwgcmVtb3ZhYmxlV2FsbHMubGVuZ3RoKTtcblxuICAgICAgICBsZXQgcmVtb3ZlZFdhbGxzID0gMDtcbiAgICAgICAgd2FsbHMuZm9yRWFjaCgod2FsbCk9PntcbiAgICAgICAgICAgIGlmKHdhbGwuc3RhdGU9PVdhbGxTdGF0ZS5QRU5ESU5HKXtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZhYmxlV2FsbHMuaW5jbHVkZXMod2FsbCkgJiYgcmVtb3ZlZFdhbGxzIDwgbnVtYmVyT2ZXYWxsc1RvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxsLnNob3VsZE5vdEJlUmVtb3ZlZCgpICYmIHJlbW92ZWRXYWxscyA+IG1pbmltdW1XYWxsc1RvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsLnN0YXRlID0gV2FsbFN0YXRlLkNPTkZJUk1FRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3YWxsLnN0YXRlID0gV2FsbFN0YXRlLlJFTU9WRUQ7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRXYWxscysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGwuc3RhdGUgPSBXYWxsU3RhdGUuQ09ORklSTUVEXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2aXNpdCgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBncm91cHMgdGhhdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoaXMgY2VsbC4gRm9yIGVhY2ggb25lLFxuICAgICAgICAvLyB0aGlzIGNlbGwgbm8gbG9uZ2VyIGNvdW50cyBhcyBhbiBcImFjY2Vzc2libGUgdW52aXNpdGVkIGNlbGxcIiwgc29cbiAgICAgICAgLy8gZGVsZXRlIGl0IGZyb20gdGhlaXIgcmVjb3Jkcy5cbiAgICAgICAgbGV0IG5laWdoYm9yaW5nR3JvdXBzID0gdGhpcy5nZXRVbmlxdWVOZWlnaGJvcmluZ0dyb3VwcygpO1xuICAgICAgICBuZWlnaGJvcmluZ0dyb3Vwcy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIChncm91cCk9PiBncm91cC5hY2Nlc3NpYmxlVW52aXNpdGVkQ2VsbHMuZGVsZXRlKHRoaXMpXG4gICAgICAgIClcblxuICAgICAgICAvLyBJZiB0aGUgbWVyZ2VkIGdyb3VwIHdoaWNoIGluY2x1ZGVzIHRoaXMgY2VsbCBhbHJlYWR5IGhhcyBhY2Nlc3MgdG9cbiAgICAgICAgLy8gYSBsZWFzdCBvbmUgdW52aXNpdGVkIGNlbGwsIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byByZW1vdmUgYW55IHdhbGxzLlxuICAgICAgICAvLyBJZiBpdCBkb2VzIE5PVCBoYXZlIGFjY2VzcyB0byBhdCBsZWFzdCBvbmUgdW52aXNpdGVkIGNlbGwsIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gbWFpbnRhaW4gYWNjZXNzIGJ5IGRlbGV0aW5nIGF0IGxlYXN0IG9uZSB3YWxsLlxuICAgICAgICBjb25zdCBtaW5XYWxsc1RvUmVtb3ZlID1cbiAgICAgICAgICAgIGdldEFsbEFjY2Vzc2libGVVbnZpc2l0ZWRDZWxscyhuZWlnaGJvcmluZ0dyb3Vwcykuc2l6ZSA/IDAgOiAxO1xuXG4gICAgICAgIC8vIFJlbW92ZSBhdCBsZWFzdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB3YWxscy5cbiAgICAgICAgdGhpcy5yZW1vdmVBdExlYXN0TldhbGxzKG1pbldhbGxzVG9SZW1vdmUpXG5cbiAgICAgICAgLy8gTm93IHRoYXQgd2UndmUgcmVtb3ZlZCBzb21lIHdhbGxzLCByZS1jYWxjdWxhdGUgdGhlIG5laWdoYm9yaW5nXG4gICAgICAgIC8vIGdyb3VwcyB0byBpbmNsdWRlIHRob3NlIHRoYXQgd2UgaGF2ZSBqdXN0IGdhaW5lZCBhY2Nlc3MgdG8uXG4gICAgICAgIC8vIE9uY2Ugd2UgbWVyZ2UsIHdlJ2xsIHdhbnQgdGhlIG5ld2x5IG1lcmdlZCBncm91cCB0byBjb3VudCwgYW1vbmcgaXRzXG4gICAgICAgIC8vIFwiYWNjZXNzaWJsZSB1bnZpc2l0ZWQgY2VsbHNcIiwgYW55dGhpbmcgYWNjZXNzaWJsZSB2aWEgdGhlc2UgbmVpZ2hib3JpbmdcbiAgICAgICAgLy8gZ3JvdXBzXG4gICAgICAgIG5laWdoYm9yaW5nR3JvdXBzID0gdGhpcy5nZXRVbmlxdWVOZWlnaGJvcmluZ0dyb3VwcygpO1xuICAgICAgICBjb25zdCBuZXdBbGxVbnZpc2l0ZWQgPSBnZXRBbGxBY2Nlc3NpYmxlVW52aXNpdGVkQ2VsbHMobmVpZ2hib3JpbmdHcm91cHMpXG5cbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgbWVyZ2UgJiB1cGRhdGUgdGhlIFwiYWNjZXNzaWJsZSB1bnZpc2l0ZWQgY2VsbHNcIlxuICAgICAgICB0aGlzLmdldFVuaXF1ZU5laWdoYm9yaW5nR3JvdXBzKHRydWUpXG4gICAgICAgICAgICAuZm9yRWFjaCgoZ3JvdXApID0+IHRoaXMuZ3JvdXAubWVyZ2VXaXRoR3JvdXAoZ3JvdXApKTtcbiAgICAgICAgdGhpcy5ncm91cC5hY2Nlc3NpYmxlVW52aXNpdGVkQ2VsbHMgPSBuZXdBbGxVbnZpc2l0ZWQ7XG5cbiAgICAgICAgLy8gTWFyayB0aGlzIGNlbGwgYXMgdmlzaXRlZFxuICAgICAgICB0aGlzLnZpc2l0ZWQgPSB0cnVlO1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBnZXRBbGxBY2Nlc3NpYmxlVW52aXNpdGVkQ2VsbHMoZ3JvdXBzKXtcbiAgICBjb25zdCBhbGxVbnZpc2l0ZWRDZWxscyA9IG5ldyBTZXQoKTtcbiAgICBncm91cHMuZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICAgICAgZ3JvdXAuYWNjZXNzaWJsZVVudmlzaXRlZENlbGxzLmZvckVhY2goKGNlbGwpPT57XG4gICAgICAgICAgICBhbGxVbnZpc2l0ZWRDZWxscy5hZGQoY2VsbClcbiAgICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gYWxsVW52aXNpdGVkQ2VsbHM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENlbGw7XG4iLCJpbXBvcnQgJy4vdXRpbHMuanMnO1xuaW1wb3J0IENlbGwgZnJvbSAnLi9DZWxsLmpzJztcbmltcG9ydCBXYWxsIGZyb20gJy4vV2FsbC5qcyc7XG5pbXBvcnQgVmVydGV4IGZyb20gJy4vVmVydGV4LmpzJztcblxuY2xhc3MgTWF6ZSB7XG4gICAgY29uc3RydWN0b3Iocm93cywgY29scykge1xuICAgICAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgICAgICB0aGlzLmNvbHMgPSBjb2xzO1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgdGhpcy52aXNpdGVkQ2VsbHNDb3VudCA9IDA7XG5cbiAgICAgICAgY29uc3QgZGF0YVR5cGVzID0gW1xuICAgICAgICAgICAgW1ZlcnRleCwgV2FsbF0sXG4gICAgICAgICAgICBbV2FsbCwgQ2VsbF1cbiAgICAgICAgXTtcblxuICAgICAgICBmb3IgKGxldCByID0gMDsgciA8IDIqcm93cysxOyByKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCAyKmNvbHMrMTsgYysrKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBlYWNoIGVudGl0eSB3aXRoIGl0cyBjb29yZGluYXRlcyBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIG1hemUuXG4gICAgICAgICAgICAgICAgcm93LnB1c2gobmV3IGRhdGFUeXBlc1tyJTJdW2MlMl0odGhpcywgciwgYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldENlbGxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnJlZHVjZSgoY2VsbHMsIHJvdykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNlbGxzLmNvbmNhdChyb3cuZmlsdGVyKChlbnRpdHkpID0+IGVudGl0eSBpbnN0YW5jZW9mIENlbGwpKTtcbiAgICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIGdlbmVyYXRlTWF6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaXRlZENlbGxzQ291bnQgPiAwKSByZXR1cm47XG4gICAgICAgIHdoaWxlICh0aGlzLmdlbmVyYXRlTmV4dENlbGwoKSkge31cbiAgICB9XG5cbiAgICBnZW5lcmF0ZU5leHRDZWxsKCkge1xuICAgICAgICBjb25zdCBjZWxscyA9IHRoaXMuZ2V0Q2VsbHMoKTtcbiAgICAgICAgaWYgKHRoaXMudmlzaXRlZENlbGxzQ291bnQgPT09IGNlbGxzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGNlbGwgPSBjZWxsc1t0aGlzLnZpc2l0ZWRDZWxsc0NvdW50XTtcbiAgICAgICAgY2VsbC52aXNpdCgpO1xuICAgICAgICB0aGlzLnZpc2l0ZWRDZWxsc0NvdW50Kys7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJpYyBpbXBsZW1lbnRhdGlvbiBvZiBicmVhZHRoLWZpcnN0IHNlYXJjaC4gUmV0dXJucyBub3RoaW5nLCBidXQgZXhwb3Nlc1xuICAgICAqIGN1c3RvbWl6YWJsZSBmdW5jdGlvbmFsaXR5IHZpYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2VsbH0gc3RhcnRDZWxsIC0gQ2VsbCB0byBiZWdpbiBzZWFyY2hpbmcgb3V0d2FyZHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRha2VzIHBhcmVudCBDZWxsLCBmb2xsb3dlZCBieSBpdHMgY2hpbGQgQ2VsbC5cbiAgICAgKi9cbiAgICBicmVhZHRoRmlyc3RTZWFyY2goc3RhcnRDZWxsLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBkaXN0YW5jZURpY3QgPSB7fTtcbiAgICAgICAgY29uc3QgdmlzaXRlZENlbGxzID0gbmV3IFNldChbc3RhcnRDZWxsXSk7XG5cbiAgICAgICAgbGV0IGZyb250aWVyQ2VsbHMgPSBbc3RhcnRDZWxsXTtcblxuICAgICAgICB3aGlsZSAoZnJvbnRpZXJDZWxscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0Zyb250aWVyID0gW107XG4gICAgICAgICAgICBmcm9udGllckNlbGxzLmZvckVhY2goKGNlbGwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NpYmxlTmVpZ2hib3JzID0gY2VsbC5nZXRBY2Nlc3NpYmxlTmVpZ2hib3JzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW52aXNpdGVkQWNjZXNzaWJsZSA9IGFjY2Vzc2libGVOZWlnaGJvcnMuZmlsdGVyKChuZWlnaGJvcikgPT4gIXZpc2l0ZWRDZWxscy5oYXMobmVpZ2hib3IpKTtcblxuICAgICAgICAgICAgICAgIHVudmlzaXRlZEFjY2Vzc2libGUuZm9yRWFjaCgodW52aXNpdGVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNlbGwsIHVudmlzaXRlZClcbiAgICAgICAgICAgICAgICAgICAgbmV3RnJvbnRpZXIucHVzaCh1bnZpc2l0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkQ2VsbHMuYWRkKHVudmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZyb250aWVyQ2VsbHMgPSBuZXdGcm9udGllcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBkaXN0YW5jZSBvZiBhbGwgbWF6ZSBjZWxscyBmcm9tIGNlbGwgYXQgZ2l2ZW4gaW5kZXgsXG4gICAgICogdGhlbiB1c2UgY29sb3IgdG8gdmlzdWFsaXplIGRpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SWR4IC0gSW5kZXggb2Ygc2VsZWN0ZWQgc3RhcnQgY2VsbC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxDZWxsLCBudW1iZXI+fSBEaWN0aW9uYXJ5IG9mIGRpc3RhbmNlcyBmcm9tIHN0YXJ0IGNlbGwuXG4gICAgICovXG4gICAgZ2V0RGlzdGFuY2VEaWN0KHN0YXJ0SWR4KXtcbiAgICAgICAgY29uc3Qgc3RhcnRDZWxsID0gdGhpcy5nZXRDZWxscygpW3N0YXJ0SWR4XTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VEaWN0ID0ge31cbiAgICAgICAgZGlzdGFuY2VEaWN0W3N0YXJ0Q2VsbF0gPSAwO1xuXG4gICAgICAgIHRoaXMuYnJlYWR0aEZpcnN0U2VhcmNoKHN0YXJ0Q2VsbCwgKHBhcmVudCwgY2hpbGQpPT57XG4gICAgICAgICAgICBkaXN0YW5jZURpY3RbY2hpbGRdID0gZGlzdGFuY2VEaWN0W3BhcmVudF0gKyAxO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGlzdGFuY2VEaWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYnJlYWR0aC1maXJzdCBzZWFyY2ggdG8gZmluZCB0aGUgc2hvcnRlc3QgcGF0aCBiZXR3ZWVuIHR3byBjZWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydElkeCAtIEluZGV4IG9mIHN0YXJ0IGNlbGwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZElkeCAtIEluZGV4IG9mIGVuZCBjZWxsLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gTGlzdCBvZiBjZWxscyBpbiBzaG9ydGVzdCBwYXRoIChpbmNsdWRpbmcgc3RhcnQgYW5kIGVuZCBjZWxsKS5cbiAgICAgKi9cbiAgICBnZXRTaG9ydGVzdFBhdGhEYXRhKHN0YXJ0SWR4LCBlbmRJZHgpe1xuICAgICAgICBjb25zdCBjZWxscyA9IHRoaXMuZ2V0Q2VsbHMoKTtcbiAgICAgICAgY29uc3Qgc3RhcnRDZWxsID0gY2VsbHNbc3RhcnRJZHhdO1xuICAgICAgICBjb25zdCBlbmRDZWxsID0gY2VsbHNbZW5kSWR4XTtcblxuICAgICAgICBjb25zdCBwcmV2aW91c0RpY3QgPSB7fVxuICAgICAgICBwcmV2aW91c0RpY3Rbc3RhcnRDZWxsXSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5icmVhZHRoRmlyc3RTZWFyY2goc3RhcnRDZWxsLCAocGFyZW50LCBjaGlsZCkgPT4ge1xuICAgICAgICAgICAgcHJldmlvdXNEaWN0W2NoaWxkXSA9IHBhcmVudDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcGF0aCA9IFtdO1xuXG4gICAgICAgIGxldCBwcmV2Q2VsbCA9IGVuZENlbGw7XG4gICAgICAgIHdoaWxlIChwcmV2Q2VsbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGF0aC51bnNoaWZ0KHByZXZDZWxsKVxuICAgICAgICAgICAgcHJldkNlbGwgPSBwcmV2aW91c0RpY3RbcHJldkNlbGxdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXplO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var _static_img_GitHub_Mark_Light_64px_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);\n/* harmony import */ var _static_img_GitHub_Mark_Light_64px_png__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_static_img_GitHub_Mark_Light_64px_png__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Maze_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);\n/* harmony import */ var _Wall_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);\n\n\n\n\n\n\nconst DISTANCE_MAP_ANIMATION_SPEED = 40; // Delay (in milliseconds) between distance steps.\nconst ANIMATION_SPEED = 40; // Delay (in milliseconds) between cell visits.\n\n// Min & max values for random mazes in animation mode.\nconst MIN_RANDOM = 8;\nconst MAX_RANDOM = 30;\n\n// Min & max for minor (i.e. short or narrow) axis of random mazes on mobile.\nconst MIN_MOBILE_MINOR = 5;\nconst MAX_MOBILE_MINOR = 10;\n\n// Min & max for major (i.e. long or wide) axis of random mazes on mobile.\nconst MIN_MOBILE_MAJOR = 10;\nconst MAX_MOBILE_MAJOR = 20;\n\n// Min & max values for user input dimensions.\nconst MIN_CUSTOM = 3;\nconst MAX_CUSTOM = 40;\n\nconst InteractionMode = {\n    SHORTEST_PATH: 'SHORTEST_PATH',\n    DISTANCE_MAP: 'DISTANCE_MAP',\n};\n\n// Helper methods\n\nfunction getColorForNormalizedDistance(distance) {\n   return `hsl(${300 * distance}, 100%, 40%)`;\n}\n\nclass MazeDemoPage {\n    constructor() {\n        this.updateRanges();\n        this.randomizeDimensions();\n\n        this.maze = null;\n\n        this.isMobile = null;\n        this.isLandscape =  null;\n\n        this.currentMode = InteractionMode.DISTANCE_MAP;\n        this.isAnimating = false;\n        this.screenSaverInterval = null;\n\n        this.pathStart = null;\n        this.pathEnd = null;\n        this.pathLength = 0;\n        this.maxLength = 0;\n\n        this.pathLength$ = $('#path-length');\n        this.maxLength$ = $('#max-length');\n\n        this.maze$ = $('#maze');\n        this.mazeBg$ = $('#maze-background');\n\n        const templates$ = $('#templates');\n        this.cellTpl$ = templates$.find('.cell');\n        this.cells$ = {};\n\n        this.tooltip$ = $('#tooltip');\n        this.toolbar$ = $('#toolbar');\n\n        $('#github-link').css('background-image', `url(./dist/${_static_img_GitHub_Mark_Light_64px_png__WEBPACK_IMPORTED_MODULE_1___default.a})`);\n\n        this.hookEvents();\n    }\n\n    hookEvents() {\n        $(window).on('resize orientationchange', () => {\n            this.updateView();\n            this.updateRanges();\n        });\n\n        this.maze$\n            .on('mouseover', '.cell', (e) => {\n                e.stopPropagation();\n\n                const cell$ = $(e.currentTarget);\n\n                if (this.isAnimating) return;\n                else if (this.currentMode === InteractionMode.SHORTEST_PATH) {\n                    if (!this.pathStart || this.pathEnd) return;\n                    this.updatePath(this.pathStart, cell$.attr('id'));\n                    this.tooltip$.show();\n                } else if (this.currentMode === InteractionMode.DISTANCE_MAP) {\n                    this.drawDistanceMap(cell$);\n                }\n            })\n            .on('click', '.cell', (e) => {\n                e.stopPropagation();\n                const cell$ = $(e.currentTarget);\n\n                if (this.isAnimating) return;\n                else if (this.currentMode === InteractionMode.SHORTEST_PATH) {\n                    const cellId = cell$.attr('id');\n\n                    if (this.pathStart && !this.pathEnd) {\n                        this.pathEnd = cellId;\n                        this.tooltip$.hide();\n                    } else {\n                        this.pathStart = cellId;\n                        this.pathEnd = null;\n\n                        this.pathLength = 0;\n                        this.maxLength = 0;\n                    }\n\n                    this.updatePath(this.pathStart, this.pathEnd);\n                } else if (this.currentMode === InteractionMode.DISTANCE_MAP) {\n                    this.animateDistanceMap(cell$);\n                }\n            });\n\n        this.toolbar$\n            .on('click', '#distance-map:not(.active)', () => {\n                this.currentMode = InteractionMode.DISTANCE_MAP;\n                this.clearPath();\n                $('#shortest-path').removeClass('active');\n                $('#distance-map').addClass('active');\n            })\n            .on('click', '#shortest-path:not(.active)', () => {\n                this.currentMode = InteractionMode.SHORTEST_PATH;\n                $('#distance-map').removeClass('active');\n                $('#shortest-path').addClass('active');\n            });\n\n        $('#new-maze').click(() => {\n            this.nRows = $('#rows').val();\n            this.nCols = $('#cols').val();\n            this.startMaze();\n        });\n\n        $('#new-maze input')\n            .click((e) => {\n                e.stopPropagation();\n            })\n            .focus((e) => {\n                const input$ = $(e.target);\n                input$.data('previous', parseInt(input$.val()));\n            })\n            .change((e) => {\n                const input$ = $(e.target);\n                const inputValue = parseInt(input$.val());\n                const prevValue = input$.data('previous');\n\n                const newValue = Math.max(Math.min(inputValue || prevValue, MAX_CUSTOM), MIN_CUSTOM);\n                input$.val(newValue);\n\n                if (newValue !== prevValue) {\n                    this.resizeInput(input$, newValue);\n                    $('#new-maze').click();\n                }\n            });\n\n        $('#start-animating').click(() => this.startAnimating());\n        $('#stop-animating').click(()=>this.stopAnimating());\n\n        $('body')\n            .on('mouseover', () => {\n                if (this.isAnimating) return;\n                else if (this.currentMode === InteractionMode.DISTANCE_MAP) {\n                    Object.values(this.cells$).forEach((cell$) => cell$.find('.walls').css('background-color', ''));\n                    this.mazeBg$.removeClass('highlight-foreground');\n                }\n                this.tooltip$.hide();\n            })\n            .on('click', () => {\n                if (this.isAnimating) return;\n                else if (this.currentMode === InteractionMode.SHORTEST_PATH) {\n                    this.clearPath();\n                }\n            });\n\n        $(document)\n            .on('mousemove', (e) => {\n                this.updateTooltip(e);\n            });\n    }\n\n    setupView() {\n        this.maze$.empty();\n        this.cells$ = {};\n\n        const cells = this.maze.getCells()\n        cells.forEach((cell, idx) => {\n            const newCell$ = this.cellTpl$.clone();\n            newCell$.attr('id', idx);\n\n            this.cells$[cell] = newCell$;\n            this.maze$.append(newCell$);\n        });\n\n        this.maze$.css({\n            'grid-template-rows': `repeat(${this.nRows}, 1fr)`,\n            'grid-template-columns': `repeat(${this.nCols}, 1fr)`\n        });\n\n        this.resizeInput($('#rows').val(this.nRows), this.nRows);\n        this.resizeInput($('#cols').val(this.nCols), this.nCols);\n\n        this.updateView();\n    }\n\n    updateRanges() {\n        const isMobile = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[/* getDeviceType */ \"a\"])()\n        const isLandscape = window.innerWidth > window.innerHeight;\n        const hasChanged = (isMobile !== this.isMobile || (isMobile && isLandscape !== this.isLandscape));\n\n        if (!hasChanged) return;\n\n        if (isMobile) {\n            if (isLandscape) {\n                this.minRandRows = MIN_MOBILE_MINOR;\n                this.maxRandRows = MAX_MOBILE_MINOR;\n                this.minRandCols = MIN_MOBILE_MAJOR;\n                this.maxRandCols = MAX_MOBILE_MAJOR;\n            } else {\n                this.minRandRows = MIN_MOBILE_MAJOR;\n                this.maxRandRows = MAX_MOBILE_MAJOR;\n                this.minRandCols = MIN_MOBILE_MINOR;\n                this.maxRandCols = MAX_MOBILE_MINOR;\n            }\n        } else {\n            this.minRandRows = MIN_RANDOM;\n            this.maxRandRows = MAX_RANDOM;\n            this.minRandCols = MIN_RANDOM;\n            this.maxRandCols = MAX_RANDOM;\n        }\n\n        // Restart animation if ranges change.\n        if (this.isMobile !== null && this.isLandscape !== null && this.screenSaverInterval) {\n            this.stopAnimating();\n            this.startAnimating();\n        }\n\n        this.isMobile = isMobile;\n        this.isLandscape = isLandscape;\n    }\n\n    randomizeDimensions() {\n        this.nRows = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[/* randInt */ \"c\"])(this.minRandRows, this.maxRandRows);\n        this.nCols = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[/* randInt */ \"c\"])(this.minRandCols, this.maxRandCols);\n    }\n\n    updateView() {\n        const vh = $(window).height() * 0.01;\n        document.documentElement.style.setProperty('--vh', `${vh}px`);\n\n        function formatHeight(height) {\n            return `calc(var(--vh, 1vh) * ${height})`;\n        }\n\n        const mazeAspect = this.nRows / this.nCols;\n        const screenAspect = $(window).height() / $(window).width();\n\n        $('body').toggleClass('mobile', Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[/* getDeviceType */ \"a\"])() && screenAspect > 1);\n\n        this.mazeBg$.css({\n            width: screenAspect > mazeAspect ? '80vw' : formatHeight(80/mazeAspect),\n            height: mazeAspect >= screenAspect ? formatHeight(80) : `${80*mazeAspect}vw`\n        });\n\n        const defaultCell$ = this.maze$.find('.cell').first();\n\n        // If cell has open any walls, remove classes before calculating padding.\n        const classes = defaultCell$.attr('class');\n        const removeClasses = classes.split(' ').length > 1;\n        if (removeClasses) {\n            defaultCell$.attr('class', 'cell');\n        }\n\n        const defaultWall$ = defaultCell$.find('.walls');\n        const mazePadding = (defaultCell$.width()-defaultWall$.width())/2;\n\n        if (removeClasses) {\n            defaultCell$.attr('class', classes);\n        }\n\n        this.mazeBg$.css({\n            padding: mazePadding,\n            'border-radius': mazePadding * 1.5\n        });\n\n        $('.vertex').css({\n            top: -mazePadding,\n            right: -mazePadding,\n            height: mazePadding*2,\n            width: mazePadding*2,\n            'border-radius': mazePadding\n        });\n    }\n\n    updatePath(start, end) {\n        Object.values(this.cells$).forEach(cell$ => cell$.removeClass('path-start path-end path-middle'));\n        if (!(start || end)) {\n            this.mazeBg$.removeClass('highlight-foreground');\n            return;\n        }\n\n        this.mazeBg$.addClass('highlight-foreground');\n\n        if (!end) {\n            const cells = this.maze.getCells();\n            this.cells$[cells[start]].addClass('path-start');\n            return;\n        }\n\n        const pathData = this.maze.getShortestPathData(start, end);\n        this.pathLength = pathData.length-1;\n        this.maxLength = Math.max(this.maxLength, this.pathLength);\n\n        pathData.forEach((cell, idx) => {\n            const cell$ = this.cells$[cell];\n            cell$.addClass(idx === 0 ? 'path-start' : idx === pathData.length - 1 ? 'path-end' : 'path-middle')\n        });\n\n        this.renderMaze(false);\n    }\n\n    clearPath() {\n        this.pathStart = null;\n        this.pathEnd = null;\n        this.updatePath(null, null);\n        this.tooltip$.hide();\n    }\n\n    updateTooltip(e) {\n        this.tooltip$.css({ top: e.clientY - this.tooltip$.innerHeight() - 20, left: e.clientX - this.tooltip$.innerWidth() / 2 });\n        this.pathLength$.html(this.pathLength);\n        this.maxLength$.html(this.maxLength);\n    }\n\n    resizeInput(input$, value) {\n        input$.css('margin', `0 -${6 * (value >= 10 ? 1 : 2)}px`);\n    }\n\n    renderMaze(withColor) {\n        const cells = this.maze.getCells();\n\n        cells.forEach((cell) => {\n            const cell$ = this.cells$[cell];\n            const wallDict = cell.getWalls();\n\n            Object.keys(wallDict).forEach((key) => {\n                if (wallDict[key].state === _Wall_js__WEBPACK_IMPORTED_MODULE_3__[/* WallState */ \"a\"].REMOVED){\n                    cell$.addClass(`open-${key}`);\n                }\n            });\n\n            const cellColor = withColor && cell.visited ? cell.group.color : '';\n            cell$.find('.walls').css('background-color', cellColor);\n\n            cell$.toggleClass('pending', !cell.visited);\n        });\n    }\n\n    startMaze() {\n        this.maze = new _Maze_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"](this.nRows, this.nCols);\n        this.setupView();\n\n        this.maze.generateMaze();\n        this.renderMaze(false);\n    }\n\n    startAnimating() {\n        this.isAnimating = true;\n\n        this.mazeBg$.addClass('highlight-foreground');\n\n        this.toolbar$.addClass('animating');\n        $('#new-maze, #interaction-mode .tool-option').disable();\n\n        let roundsToSkip = 1;\n        this.screenSaverInterval = setInterval(() => {\n            if (roundsToSkip > 0) {\n                roundsToSkip--;\n                if (!roundsToSkip) {\n                    this.randomizeDimensions();\n\n                    this.maze = new _Maze_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"](this.nRows, this.nCols);\n                    this.setupView();\n                }\n            } else {\n                const shouldRepeat = this.maze.generateNextCell();\n                this.renderMaze(true);\n\n                if (!shouldRepeat) {\n                    roundsToSkip = 30;\n                }\n            }\n        }, ANIMATION_SPEED);\n    }\n\n    stopAnimating() {\n        this.isAnimating = false;\n\n        this.mazeBg$.removeClass('highlight-foreground');\n\n        this.toolbar$.removeClass('animating');\n        $('#new-maze, #interaction-mode .tool-option').enable();\n\n        clearInterval(this.screenSaverInterval);\n        this.screenSaverInterval = null;\n\n        while (this.maze.generateNextCell()) {}\n\n        this.renderMaze();\n    }\n\n    drawDistanceMap(startCell$) {\n        const distanceDict = this.maze.getDistanceDict(startCell$.attr('id'));\n        const maxDist = Object.values(distanceDict).sort((a, b) => parseInt(a) > parseInt(b) ? -1 : 1)[0];\n\n        // Set hue by normalized distance (i.e. fraction of max dist).\n        this.maze.getCells().forEach((cell) => {\n            this.cells$[cell].find('.walls').css('background-color', getColorForNormalizedDistance(distanceDict[cell] / maxDist));\n        });\n\n        this.mazeBg$.addClass('highlight-foreground');\n    }\n\n    animateDistanceMap(startCell$) {\n        this.isAnimating = true;\n        this.renderMaze(false);\n\n        this.toolbar$.find('.tool-option').disable();\n\n        const distanceDict = this.maze.getDistanceDict(startCell$.attr('id'));\n        const reversedDict = {};\n        Object.keys(distanceDict).forEach((cell) => {\n            const distance = distanceDict[cell];\n            if (!(distance in reversedDict)) {\n                reversedDict[distance] = [];\n            }\n            reversedDict[distance].push(cell)\n        });\n        const maxDist = Object.keys(reversedDict).length;\n        let currentDist = 0;\n        const distanceInterval = setInterval(()=>{\n            if (currentDist < maxDist) {\n                const cells = reversedDict[currentDist];\n                cells.forEach((cell)=>{\n                    this.cells$[cell].find('.walls').css('background-color', getColorForNormalizedDistance(currentDist / maxDist));\n                });\n                currentDist++;\n            }\n            else {\n                clearInterval(distanceInterval);\n\n                this.isAnimating = false;\n                this.toolbar$.find('.tool-option').enable();\n            }\n        }, DISTANCE_MAP_ANIMATION_SPEED);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (MazeDemoPage);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9NYXplRGVtb1BhZ2UuanM/YjUxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3JhbmRJbnQsIGdldERldmljZVR5cGV9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IEdpdEh1YkxvZ28gZnJvbSAnLi4vLi4vc3RhdGljL2ltZy9HaXRIdWItTWFyay1MaWdodC02NHB4LnBuZyc7XG5pbXBvcnQgTWF6ZSBmcm9tICcuL01hemUuanMnO1xuaW1wb3J0IFdhbGwgZnJvbSAnLi9XYWxsLmpzJ1xuaW1wb3J0IHtXYWxsU3RhdGV9IGZyb20gJy4vV2FsbC5qcydcblxuY29uc3QgRElTVEFOQ0VfTUFQX0FOSU1BVElPTl9TUEVFRCA9IDQwOyAvLyBEZWxheSAoaW4gbWlsbGlzZWNvbmRzKSBiZXR3ZWVuIGRpc3RhbmNlIHN0ZXBzLlxuY29uc3QgQU5JTUFUSU9OX1NQRUVEID0gNDA7IC8vIERlbGF5IChpbiBtaWxsaXNlY29uZHMpIGJldHdlZW4gY2VsbCB2aXNpdHMuXG5cbi8vIE1pbiAmIG1heCB2YWx1ZXMgZm9yIHJhbmRvbSBtYXplcyBpbiBhbmltYXRpb24gbW9kZS5cbmNvbnN0IE1JTl9SQU5ET00gPSA4O1xuY29uc3QgTUFYX1JBTkRPTSA9IDMwO1xuXG4vLyBNaW4gJiBtYXggZm9yIG1pbm9yIChpLmUuIHNob3J0IG9yIG5hcnJvdykgYXhpcyBvZiByYW5kb20gbWF6ZXMgb24gbW9iaWxlLlxuY29uc3QgTUlOX01PQklMRV9NSU5PUiA9IDU7XG5jb25zdCBNQVhfTU9CSUxFX01JTk9SID0gMTA7XG5cbi8vIE1pbiAmIG1heCBmb3IgbWFqb3IgKGkuZS4gbG9uZyBvciB3aWRlKSBheGlzIG9mIHJhbmRvbSBtYXplcyBvbiBtb2JpbGUuXG5jb25zdCBNSU5fTU9CSUxFX01BSk9SID0gMTA7XG5jb25zdCBNQVhfTU9CSUxFX01BSk9SID0gMjA7XG5cbi8vIE1pbiAmIG1heCB2YWx1ZXMgZm9yIHVzZXIgaW5wdXQgZGltZW5zaW9ucy5cbmNvbnN0IE1JTl9DVVNUT00gPSAzO1xuY29uc3QgTUFYX0NVU1RPTSA9IDQwO1xuXG5jb25zdCBJbnRlcmFjdGlvbk1vZGUgPSB7XG4gICAgU0hPUlRFU1RfUEFUSDogJ1NIT1JURVNUX1BBVEgnLFxuICAgIERJU1RBTkNFX01BUDogJ0RJU1RBTkNFX01BUCcsXG59O1xuXG4vLyBIZWxwZXIgbWV0aG9kc1xuXG5mdW5jdGlvbiBnZXRDb2xvckZvck5vcm1hbGl6ZWREaXN0YW5jZShkaXN0YW5jZSkge1xuICAgcmV0dXJuIGBoc2woJHszMDAgKiBkaXN0YW5jZX0sIDEwMCUsIDQwJSlgO1xufVxuXG5jbGFzcyBNYXplRGVtb1BhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlcygpO1xuICAgICAgICB0aGlzLnJhbmRvbWl6ZURpbWVuc2lvbnMoKTtcblxuICAgICAgICB0aGlzLm1hemUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaXNNb2JpbGUgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTGFuZHNjYXBlID0gIG51bGw7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50TW9kZSA9IEludGVyYWN0aW9uTW9kZS5ESVNUQU5DRV9NQVA7XG4gICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY3JlZW5TYXZlckludGVydmFsID0gbnVsbDtcblxuICAgICAgICB0aGlzLnBhdGhTdGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMucGF0aEVuZCA9IG51bGw7XG4gICAgICAgIHRoaXMucGF0aExlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gMDtcblxuICAgICAgICB0aGlzLnBhdGhMZW5ndGgkID0gJCgnI3BhdGgtbGVuZ3RoJyk7XG4gICAgICAgIHRoaXMubWF4TGVuZ3RoJCA9ICQoJyNtYXgtbGVuZ3RoJyk7XG5cbiAgICAgICAgdGhpcy5tYXplJCA9ICQoJyNtYXplJyk7XG4gICAgICAgIHRoaXMubWF6ZUJnJCA9ICQoJyNtYXplLWJhY2tncm91bmQnKTtcblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZXMkID0gJCgnI3RlbXBsYXRlcycpO1xuICAgICAgICB0aGlzLmNlbGxUcGwkID0gdGVtcGxhdGVzJC5maW5kKCcuY2VsbCcpO1xuICAgICAgICB0aGlzLmNlbGxzJCA9IHt9O1xuXG4gICAgICAgIHRoaXMudG9vbHRpcCQgPSAkKCcjdG9vbHRpcCcpO1xuICAgICAgICB0aGlzLnRvb2xiYXIkID0gJCgnI3Rvb2xiYXInKTtcblxuICAgICAgICAkKCcjZ2l0aHViLWxpbmsnKS5jc3MoJ2JhY2tncm91bmQtaW1hZ2UnLCBgdXJsKC4vZGlzdC8ke0dpdEh1YkxvZ299KWApO1xuXG4gICAgICAgIHRoaXMuaG9va0V2ZW50cygpO1xuICAgIH1cblxuICAgIGhvb2tFdmVudHMoKSB7XG4gICAgICAgICQod2luZG93KS5vbigncmVzaXplIG9yaWVudGF0aW9uY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlcygpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1hemUkXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsICcuY2VsbCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwkID0gJChlLmN1cnJlbnRUYXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBbmltYXRpbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmN1cnJlbnRNb2RlID09PSBJbnRlcmFjdGlvbk1vZGUuU0hPUlRFU1RfUEFUSCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGF0aFN0YXJ0IHx8IHRoaXMucGF0aEVuZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBhdGgodGhpcy5wYXRoU3RhcnQsIGNlbGwkLmF0dHIoJ2lkJykpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAkLnNob3coKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudE1vZGUgPT09IEludGVyYWN0aW9uTW9kZS5ESVNUQU5DRV9NQVApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3RGlzdGFuY2VNYXAoY2VsbCQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgJy5jZWxsJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwkID0gJChlLmN1cnJlbnRUYXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBbmltYXRpbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmN1cnJlbnRNb2RlID09PSBJbnRlcmFjdGlvbk1vZGUuU0hPUlRFU1RfUEFUSCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsSWQgPSBjZWxsJC5hdHRyKCdpZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhdGhTdGFydCAmJiAhdGhpcy5wYXRoRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhFbmQgPSBjZWxsSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAkLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aFN0YXJ0ID0gY2VsbElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoRW5kID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF4TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGF0aCh0aGlzLnBhdGhTdGFydCwgdGhpcy5wYXRoRW5kKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudE1vZGUgPT09IEludGVyYWN0aW9uTW9kZS5ESVNUQU5DRV9NQVApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlRGlzdGFuY2VNYXAoY2VsbCQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudG9vbGJhciRcbiAgICAgICAgICAgIC5vbignY2xpY2snLCAnI2Rpc3RhbmNlLW1hcDpub3QoLmFjdGl2ZSknLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TW9kZSA9IEludGVyYWN0aW9uTW9kZS5ESVNUQU5DRV9NQVA7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclBhdGgoKTtcbiAgICAgICAgICAgICAgICAkKCcjc2hvcnRlc3QtcGF0aCcpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAkKCcjZGlzdGFuY2UtbWFwJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCAnI3Nob3J0ZXN0LXBhdGg6bm90KC5hY3RpdmUpJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1vZGUgPSBJbnRlcmFjdGlvbk1vZGUuU0hPUlRFU1RfUEFUSDtcbiAgICAgICAgICAgICAgICAkKCcjZGlzdGFuY2UtbWFwJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgICQoJyNzaG9ydGVzdC1wYXRoJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgJCgnI25ldy1tYXplJykuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uUm93cyA9ICQoJyNyb3dzJykudmFsKCk7XG4gICAgICAgICAgICB0aGlzLm5Db2xzID0gJCgnI2NvbHMnKS52YWwoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRNYXplKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoJyNuZXctbWF6ZSBpbnB1dCcpXG4gICAgICAgICAgICAuY2xpY2soKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mb2N1cygoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0JCA9ICQoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlucHV0JC5kYXRhKCdwcmV2aW91cycsIHBhcnNlSW50KGlucHV0JC52YWwoKSkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jaGFuZ2UoKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCQgPSAkKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dFZhbHVlID0gcGFyc2VJbnQoaW5wdXQkLnZhbCgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2VmFsdWUgPSBpbnB1dCQuZGF0YSgncHJldmlvdXMnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4oaW5wdXRWYWx1ZSB8fCBwcmV2VmFsdWUsIE1BWF9DVVNUT00pLCBNSU5fQ1VTVE9NKTtcbiAgICAgICAgICAgICAgICBpbnB1dCQudmFsKG5ld1ZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gcHJldlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplSW5wdXQoaW5wdXQkLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICQoJyNuZXctbWF6ZScpLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgJCgnI3N0YXJ0LWFuaW1hdGluZycpLmNsaWNrKCgpID0+IHRoaXMuc3RhcnRBbmltYXRpbmcoKSk7XG4gICAgICAgICQoJyNzdG9wLWFuaW1hdGluZycpLmNsaWNrKCgpPT50aGlzLnN0b3BBbmltYXRpbmcoKSk7XG5cbiAgICAgICAgJCgnYm9keScpXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FuaW1hdGluZykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VycmVudE1vZGUgPT09IEludGVyYWN0aW9uTW9kZS5ESVNUQU5DRV9NQVApIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLmNlbGxzJCkuZm9yRWFjaCgoY2VsbCQpID0+IGNlbGwkLmZpbmQoJy53YWxscycpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsICcnKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF6ZUJnJC5yZW1vdmVDbGFzcygnaGlnaGxpZ2h0LWZvcmVncm91bmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50b29sdGlwJC5oaWRlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FuaW1hdGluZykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VycmVudE1vZGUgPT09IEludGVyYWN0aW9uTW9kZS5TSE9SVEVTVF9QQVRIKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJQYXRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgJChkb2N1bWVudClcbiAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXAoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXR1cFZpZXcoKSB7XG4gICAgICAgIHRoaXMubWF6ZSQuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5jZWxscyQgPSB7fTtcblxuICAgICAgICBjb25zdCBjZWxscyA9IHRoaXMubWF6ZS5nZXRDZWxscygpXG4gICAgICAgIGNlbGxzLmZvckVhY2goKGNlbGwsIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3Q2VsbCQgPSB0aGlzLmNlbGxUcGwkLmNsb25lKCk7XG4gICAgICAgICAgICBuZXdDZWxsJC5hdHRyKCdpZCcsIGlkeCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2VsbHMkW2NlbGxdID0gbmV3Q2VsbCQ7XG4gICAgICAgICAgICB0aGlzLm1hemUkLmFwcGVuZChuZXdDZWxsJCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWF6ZSQuY3NzKHtcbiAgICAgICAgICAgICdncmlkLXRlbXBsYXRlLXJvd3MnOiBgcmVwZWF0KCR7dGhpcy5uUm93c30sIDFmcilgLFxuICAgICAgICAgICAgJ2dyaWQtdGVtcGxhdGUtY29sdW1ucyc6IGByZXBlYXQoJHt0aGlzLm5Db2xzfSwgMWZyKWBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZXNpemVJbnB1dCgkKCcjcm93cycpLnZhbCh0aGlzLm5Sb3dzKSwgdGhpcy5uUm93cyk7XG4gICAgICAgIHRoaXMucmVzaXplSW5wdXQoJCgnI2NvbHMnKS52YWwodGhpcy5uQ29scyksIHRoaXMubkNvbHMpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlVmlldygpO1xuICAgIH1cblxuICAgIHVwZGF0ZVJhbmdlcygpIHtcbiAgICAgICAgY29uc3QgaXNNb2JpbGUgPSBnZXREZXZpY2VUeXBlKClcbiAgICAgICAgY29uc3QgaXNMYW5kc2NhcGUgPSB3aW5kb3cuaW5uZXJXaWR0aCA+IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgY29uc3QgaGFzQ2hhbmdlZCA9IChpc01vYmlsZSAhPT0gdGhpcy5pc01vYmlsZSB8fCAoaXNNb2JpbGUgJiYgaXNMYW5kc2NhcGUgIT09IHRoaXMuaXNMYW5kc2NhcGUpKTtcblxuICAgICAgICBpZiAoIWhhc0NoYW5nZWQpIHJldHVybjtcblxuICAgICAgICBpZiAoaXNNb2JpbGUpIHtcbiAgICAgICAgICAgIGlmIChpc0xhbmRzY2FwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWluUmFuZFJvd3MgPSBNSU5fTU9CSUxFX01JTk9SO1xuICAgICAgICAgICAgICAgIHRoaXMubWF4UmFuZFJvd3MgPSBNQVhfTU9CSUxFX01JTk9SO1xuICAgICAgICAgICAgICAgIHRoaXMubWluUmFuZENvbHMgPSBNSU5fTU9CSUxFX01BSk9SO1xuICAgICAgICAgICAgICAgIHRoaXMubWF4UmFuZENvbHMgPSBNQVhfTU9CSUxFX01BSk9SO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pblJhbmRSb3dzID0gTUlOX01PQklMRV9NQUpPUjtcbiAgICAgICAgICAgICAgICB0aGlzLm1heFJhbmRSb3dzID0gTUFYX01PQklMRV9NQUpPUjtcbiAgICAgICAgICAgICAgICB0aGlzLm1pblJhbmRDb2xzID0gTUlOX01PQklMRV9NSU5PUjtcbiAgICAgICAgICAgICAgICB0aGlzLm1heFJhbmRDb2xzID0gTUFYX01PQklMRV9NSU5PUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWluUmFuZFJvd3MgPSBNSU5fUkFORE9NO1xuICAgICAgICAgICAgdGhpcy5tYXhSYW5kUm93cyA9IE1BWF9SQU5ET007XG4gICAgICAgICAgICB0aGlzLm1pblJhbmRDb2xzID0gTUlOX1JBTkRPTTtcbiAgICAgICAgICAgIHRoaXMubWF4UmFuZENvbHMgPSBNQVhfUkFORE9NO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzdGFydCBhbmltYXRpb24gaWYgcmFuZ2VzIGNoYW5nZS5cbiAgICAgICAgaWYgKHRoaXMuaXNNb2JpbGUgIT09IG51bGwgJiYgdGhpcy5pc0xhbmRzY2FwZSAhPT0gbnVsbCAmJiB0aGlzLnNjcmVlblNhdmVySW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcEFuaW1hdGluZygpO1xuICAgICAgICAgICAgdGhpcy5zdGFydEFuaW1hdGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc01vYmlsZSA9IGlzTW9iaWxlO1xuICAgICAgICB0aGlzLmlzTGFuZHNjYXBlID0gaXNMYW5kc2NhcGU7XG4gICAgfVxuXG4gICAgcmFuZG9taXplRGltZW5zaW9ucygpIHtcbiAgICAgICAgdGhpcy5uUm93cyA9IHJhbmRJbnQodGhpcy5taW5SYW5kUm93cywgdGhpcy5tYXhSYW5kUm93cyk7XG4gICAgICAgIHRoaXMubkNvbHMgPSByYW5kSW50KHRoaXMubWluUmFuZENvbHMsIHRoaXMubWF4UmFuZENvbHMpO1xuICAgIH1cblxuICAgIHVwZGF0ZVZpZXcoKSB7XG4gICAgICAgIGNvbnN0IHZoID0gJCh3aW5kb3cpLmhlaWdodCgpICogMC4wMTtcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCctLXZoJywgYCR7dmh9cHhgKTtcblxuICAgICAgICBmdW5jdGlvbiBmb3JtYXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gYGNhbGModmFyKC0tdmgsIDF2aCkgKiAke2hlaWdodH0pYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1hemVBc3BlY3QgPSB0aGlzLm5Sb3dzIC8gdGhpcy5uQ29scztcbiAgICAgICAgY29uc3Qgc2NyZWVuQXNwZWN0ID0gJCh3aW5kb3cpLmhlaWdodCgpIC8gJCh3aW5kb3cpLndpZHRoKCk7XG5cbiAgICAgICAgJCgnYm9keScpLnRvZ2dsZUNsYXNzKCdtb2JpbGUnLCBnZXREZXZpY2VUeXBlKCkgJiYgc2NyZWVuQXNwZWN0ID4gMSk7XG5cbiAgICAgICAgdGhpcy5tYXplQmckLmNzcyh7XG4gICAgICAgICAgICB3aWR0aDogc2NyZWVuQXNwZWN0ID4gbWF6ZUFzcGVjdCA/ICc4MHZ3JyA6IGZvcm1hdEhlaWdodCg4MC9tYXplQXNwZWN0KSxcbiAgICAgICAgICAgIGhlaWdodDogbWF6ZUFzcGVjdCA+PSBzY3JlZW5Bc3BlY3QgPyBmb3JtYXRIZWlnaHQoODApIDogYCR7ODAqbWF6ZUFzcGVjdH12d2BcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZGVmYXVsdENlbGwkID0gdGhpcy5tYXplJC5maW5kKCcuY2VsbCcpLmZpcnN0KCk7XG5cbiAgICAgICAgLy8gSWYgY2VsbCBoYXMgb3BlbiBhbnkgd2FsbHMsIHJlbW92ZSBjbGFzc2VzIGJlZm9yZSBjYWxjdWxhdGluZyBwYWRkaW5nLlxuICAgICAgICBjb25zdCBjbGFzc2VzID0gZGVmYXVsdENlbGwkLmF0dHIoJ2NsYXNzJyk7XG4gICAgICAgIGNvbnN0IHJlbW92ZUNsYXNzZXMgPSBjbGFzc2VzLnNwbGl0KCcgJykubGVuZ3RoID4gMTtcbiAgICAgICAgaWYgKHJlbW92ZUNsYXNzZXMpIHtcbiAgICAgICAgICAgIGRlZmF1bHRDZWxsJC5hdHRyKCdjbGFzcycsICdjZWxsJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZWZhdWx0V2FsbCQgPSBkZWZhdWx0Q2VsbCQuZmluZCgnLndhbGxzJyk7XG4gICAgICAgIGNvbnN0IG1hemVQYWRkaW5nID0gKGRlZmF1bHRDZWxsJC53aWR0aCgpLWRlZmF1bHRXYWxsJC53aWR0aCgpKS8yO1xuXG4gICAgICAgIGlmIChyZW1vdmVDbGFzc2VzKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q2VsbCQuYXR0cignY2xhc3MnLCBjbGFzc2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWF6ZUJnJC5jc3Moe1xuICAgICAgICAgICAgcGFkZGluZzogbWF6ZVBhZGRpbmcsXG4gICAgICAgICAgICAnYm9yZGVyLXJhZGl1cyc6IG1hemVQYWRkaW5nICogMS41XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoJy52ZXJ0ZXgnKS5jc3Moe1xuICAgICAgICAgICAgdG9wOiAtbWF6ZVBhZGRpbmcsXG4gICAgICAgICAgICByaWdodDogLW1hemVQYWRkaW5nLFxuICAgICAgICAgICAgaGVpZ2h0OiBtYXplUGFkZGluZyoyLFxuICAgICAgICAgICAgd2lkdGg6IG1hemVQYWRkaW5nKjIsXG4gICAgICAgICAgICAnYm9yZGVyLXJhZGl1cyc6IG1hemVQYWRkaW5nXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZVBhdGgoc3RhcnQsIGVuZCkge1xuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMuY2VsbHMkKS5mb3JFYWNoKGNlbGwkID0+IGNlbGwkLnJlbW92ZUNsYXNzKCdwYXRoLXN0YXJ0IHBhdGgtZW5kIHBhdGgtbWlkZGxlJykpO1xuICAgICAgICBpZiAoIShzdGFydCB8fCBlbmQpKSB7XG4gICAgICAgICAgICB0aGlzLm1hemVCZyQucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodC1mb3JlZ3JvdW5kJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hemVCZyQuYWRkQ2xhc3MoJ2hpZ2hsaWdodC1mb3JlZ3JvdW5kJyk7XG5cbiAgICAgICAgaWYgKCFlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxzID0gdGhpcy5tYXplLmdldENlbGxzKCk7XG4gICAgICAgICAgICB0aGlzLmNlbGxzJFtjZWxsc1tzdGFydF1dLmFkZENsYXNzKCdwYXRoLXN0YXJ0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXRoRGF0YSA9IHRoaXMubWF6ZS5nZXRTaG9ydGVzdFBhdGhEYXRhKHN0YXJ0LCBlbmQpO1xuICAgICAgICB0aGlzLnBhdGhMZW5ndGggPSBwYXRoRGF0YS5sZW5ndGgtMTtcbiAgICAgICAgdGhpcy5tYXhMZW5ndGggPSBNYXRoLm1heCh0aGlzLm1heExlbmd0aCwgdGhpcy5wYXRoTGVuZ3RoKTtcblxuICAgICAgICBwYXRoRGF0YS5mb3JFYWNoKChjZWxsLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwkID0gdGhpcy5jZWxscyRbY2VsbF07XG4gICAgICAgICAgICBjZWxsJC5hZGRDbGFzcyhpZHggPT09IDAgPyAncGF0aC1zdGFydCcgOiBpZHggPT09IHBhdGhEYXRhLmxlbmd0aCAtIDEgPyAncGF0aC1lbmQnIDogJ3BhdGgtbWlkZGxlJylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJNYXplKGZhbHNlKTtcbiAgICB9XG5cbiAgICBjbGVhclBhdGgoKSB7XG4gICAgICAgIHRoaXMucGF0aFN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXRoRW5kID0gbnVsbDtcbiAgICAgICAgdGhpcy51cGRhdGVQYXRoKG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLnRvb2x0aXAkLmhpZGUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVUb29sdGlwKGUpIHtcbiAgICAgICAgdGhpcy50b29sdGlwJC5jc3MoeyB0b3A6IGUuY2xpZW50WSAtIHRoaXMudG9vbHRpcCQuaW5uZXJIZWlnaHQoKSAtIDIwLCBsZWZ0OiBlLmNsaWVudFggLSB0aGlzLnRvb2x0aXAkLmlubmVyV2lkdGgoKSAvIDIgfSk7XG4gICAgICAgIHRoaXMucGF0aExlbmd0aCQuaHRtbCh0aGlzLnBhdGhMZW5ndGgpO1xuICAgICAgICB0aGlzLm1heExlbmd0aCQuaHRtbCh0aGlzLm1heExlbmd0aCk7XG4gICAgfVxuXG4gICAgcmVzaXplSW5wdXQoaW5wdXQkLCB2YWx1ZSkge1xuICAgICAgICBpbnB1dCQuY3NzKCdtYXJnaW4nLCBgMCAtJHs2ICogKHZhbHVlID49IDEwID8gMSA6IDIpfXB4YCk7XG4gICAgfVxuXG4gICAgcmVuZGVyTWF6ZSh3aXRoQ29sb3IpIHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSB0aGlzLm1hemUuZ2V0Q2VsbHMoKTtcblxuICAgICAgICBjZWxscy5mb3JFYWNoKChjZWxsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjZWxsJCA9IHRoaXMuY2VsbHMkW2NlbGxdO1xuICAgICAgICAgICAgY29uc3Qgd2FsbERpY3QgPSBjZWxsLmdldFdhbGxzKCk7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHdhbGxEaWN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAod2FsbERpY3Rba2V5XS5zdGF0ZSA9PT0gV2FsbFN0YXRlLlJFTU9WRUQpe1xuICAgICAgICAgICAgICAgICAgICBjZWxsJC5hZGRDbGFzcyhgb3Blbi0ke2tleX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgY2VsbENvbG9yID0gd2l0aENvbG9yICYmIGNlbGwudmlzaXRlZCA/IGNlbGwuZ3JvdXAuY29sb3IgOiAnJztcbiAgICAgICAgICAgIGNlbGwkLmZpbmQoJy53YWxscycpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIGNlbGxDb2xvcik7XG5cbiAgICAgICAgICAgIGNlbGwkLnRvZ2dsZUNsYXNzKCdwZW5kaW5nJywgIWNlbGwudmlzaXRlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXJ0TWF6ZSgpIHtcbiAgICAgICAgdGhpcy5tYXplID0gbmV3IE1hemUodGhpcy5uUm93cywgdGhpcy5uQ29scyk7XG4gICAgICAgIHRoaXMuc2V0dXBWaWV3KCk7XG5cbiAgICAgICAgdGhpcy5tYXplLmdlbmVyYXRlTWF6ZSgpO1xuICAgICAgICB0aGlzLnJlbmRlck1hemUoZmFsc2UpO1xuICAgIH1cblxuICAgIHN0YXJ0QW5pbWF0aW5nKCkge1xuICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLm1hemVCZyQuYWRkQ2xhc3MoJ2hpZ2hsaWdodC1mb3JlZ3JvdW5kJyk7XG5cbiAgICAgICAgdGhpcy50b29sYmFyJC5hZGRDbGFzcygnYW5pbWF0aW5nJyk7XG4gICAgICAgICQoJyNuZXctbWF6ZSwgI2ludGVyYWN0aW9uLW1vZGUgLnRvb2wtb3B0aW9uJykuZGlzYWJsZSgpO1xuXG4gICAgICAgIGxldCByb3VuZHNUb1NraXAgPSAxO1xuICAgICAgICB0aGlzLnNjcmVlblNhdmVySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAocm91bmRzVG9Ta2lwID4gMCkge1xuICAgICAgICAgICAgICAgIHJvdW5kc1RvU2tpcC0tO1xuICAgICAgICAgICAgICAgIGlmICghcm91bmRzVG9Ta2lwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFuZG9taXplRGltZW5zaW9ucygpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF6ZSA9IG5ldyBNYXplKHRoaXMublJvd3MsIHRoaXMubkNvbHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHVwVmlldygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVwZWF0ID0gdGhpcy5tYXplLmdlbmVyYXRlTmV4dENlbGwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck1hemUodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJlcGVhdCkge1xuICAgICAgICAgICAgICAgICAgICByb3VuZHNUb1NraXAgPSAzMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIEFOSU1BVElPTl9TUEVFRCk7XG4gICAgfVxuXG4gICAgc3RvcEFuaW1hdGluZygpIHtcbiAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMubWF6ZUJnJC5yZW1vdmVDbGFzcygnaGlnaGxpZ2h0LWZvcmVncm91bmQnKTtcblxuICAgICAgICB0aGlzLnRvb2xiYXIkLnJlbW92ZUNsYXNzKCdhbmltYXRpbmcnKTtcbiAgICAgICAgJCgnI25ldy1tYXplLCAjaW50ZXJhY3Rpb24tbW9kZSAudG9vbC1vcHRpb24nKS5lbmFibGUoKTtcblxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuc2NyZWVuU2F2ZXJJbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuc2NyZWVuU2F2ZXJJbnRlcnZhbCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMubWF6ZS5nZW5lcmF0ZU5leHRDZWxsKCkpIHt9XG5cbiAgICAgICAgdGhpcy5yZW5kZXJNYXplKCk7XG4gICAgfVxuXG4gICAgZHJhd0Rpc3RhbmNlTWFwKHN0YXJ0Q2VsbCQpIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VEaWN0ID0gdGhpcy5tYXplLmdldERpc3RhbmNlRGljdChzdGFydENlbGwkLmF0dHIoJ2lkJykpO1xuICAgICAgICBjb25zdCBtYXhEaXN0ID0gT2JqZWN0LnZhbHVlcyhkaXN0YW5jZURpY3QpLnNvcnQoKGEsIGIpID0+IHBhcnNlSW50KGEpID4gcGFyc2VJbnQoYikgPyAtMSA6IDEpWzBdO1xuXG4gICAgICAgIC8vIFNldCBodWUgYnkgbm9ybWFsaXplZCBkaXN0YW5jZSAoaS5lLiBmcmFjdGlvbiBvZiBtYXggZGlzdCkuXG4gICAgICAgIHRoaXMubWF6ZS5nZXRDZWxscygpLmZvckVhY2goKGNlbGwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2VsbHMkW2NlbGxdLmZpbmQoJy53YWxscycpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIGdldENvbG9yRm9yTm9ybWFsaXplZERpc3RhbmNlKGRpc3RhbmNlRGljdFtjZWxsXSAvIG1heERpc3QpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tYXplQmckLmFkZENsYXNzKCdoaWdobGlnaHQtZm9yZWdyb3VuZCcpO1xuICAgIH1cblxuICAgIGFuaW1hdGVEaXN0YW5jZU1hcChzdGFydENlbGwkKSB7XG4gICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbmRlck1hemUoZmFsc2UpO1xuXG4gICAgICAgIHRoaXMudG9vbGJhciQuZmluZCgnLnRvb2wtb3B0aW9uJykuZGlzYWJsZSgpO1xuXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlRGljdCA9IHRoaXMubWF6ZS5nZXREaXN0YW5jZURpY3Qoc3RhcnRDZWxsJC5hdHRyKCdpZCcpKTtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWREaWN0ID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGRpc3RhbmNlRGljdCkuZm9yRWFjaCgoY2VsbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBkaXN0YW5jZURpY3RbY2VsbF07XG4gICAgICAgICAgICBpZiAoIShkaXN0YW5jZSBpbiByZXZlcnNlZERpY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZWREaWN0W2Rpc3RhbmNlXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV2ZXJzZWREaWN0W2Rpc3RhbmNlXS5wdXNoKGNlbGwpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtYXhEaXN0ID0gT2JqZWN0LmtleXMocmV2ZXJzZWREaWN0KS5sZW5ndGg7XG4gICAgICAgIGxldCBjdXJyZW50RGlzdCA9IDA7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKT0+e1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREaXN0IDwgbWF4RGlzdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxzID0gcmV2ZXJzZWREaWN0W2N1cnJlbnREaXN0XTtcbiAgICAgICAgICAgICAgICBjZWxscy5mb3JFYWNoKChjZWxsKT0+e1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxzJFtjZWxsXS5maW5kKCcud2FsbHMnKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBnZXRDb2xvckZvck5vcm1hbGl6ZWREaXN0YW5jZShjdXJyZW50RGlzdCAvIG1heERpc3QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGlzdCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChkaXN0YW5jZUludGVydmFsKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xiYXIkLmZpbmQoJy50b29sLW9wdGlvbicpLmVuYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBESVNUQU5DRV9NQVBfQU5JTUFUSU9OX1NQRUVEKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hemVEZW1vUGFnZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n")},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "eb94bb97c3410733ce017b184d314723.png";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3N0YXRpYy9pbWcvR2l0SHViLU1hcmstTGlnaHQtNjRweC5wbmc/OTllNCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJlYjk0YmI5N2MzNDEwNzMzY2UwMTdiMTg0ZDMxNDcyMy5wbmdcIjsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _less_demo_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);\n/* harmony import */ var _less_demo_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_less_demo_less__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _less_demo_mobile_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);\n/* harmony import */ var _less_demo_mobile_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_less_demo_mobile_less__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _MazeDemoPage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);\n\n\n\n\n\nlet DemoPage;\n\n$(document).ready(() => {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__[/* initUtils */ "b"])();\n    DemoPage = new _MazeDemoPage_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]();\n    DemoPage.startMaze();\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9pbmRleC5qcz83YmE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vbGVzcy9kZW1vLmxlc3MnO1xuaW1wb3J0ICcuLi9sZXNzL2RlbW8tbW9iaWxlLmxlc3MnO1xuaW1wb3J0IE1hemVEZW1vUGFnZSBmcm9tICcuL01hemVEZW1vUGFnZS5qcyc7XG5pbXBvcnQge2luaXRVdGlsc30gZnJvbSAnLi91dGlscy5qcyc7XG5cbmxldCBEZW1vUGFnZTtcblxuJChkb2N1bWVudCkucmVhZHkoKCkgPT4ge1xuICAgIGluaXRVdGlscygpO1xuICAgIERlbW9QYWdlID0gbmV3IE1hemVEZW1vUGFnZSgpO1xuICAgIERlbW9QYWdlLnN0YXJ0TWF6ZSgpO1xufSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n')},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9sZXNzL2RlbW8ubGVzcz8yYmIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGVzcy9kZW1vLW1vYmlsZS5sZXNzPzFiYjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n")}]);